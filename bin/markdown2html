#!/usr/bin/perl

use strict;
use warnings;
use 5.10.0;
use utf8;
use Cwd "realpath";
use open qw(:std :utf8);
#binmode(STDIN,  ":encoding(utf8)");
#binmode(STDOUT, ":encoding(utf8)");

use Data::Dumper;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Indent   = 1;
$Data::Dumper::Terse    = 1;


###############################################################################
##                                                                           ##
##  Settings                                                                 ##
##                                                                           ##
###############################################################################

my %code = (
    AUTHOR    => \&page_author,    # in 'template.html'
    AUTHORTXT => \&page_authortxt, # in 'template.html'
    CHANGED   => \&page_changed,   # in 'template.html'
    CRUMBS    => \&page_crumbs,    # in 'template.html'
    EOF       => sub { () },       # in all templates
    FOOTER    => \&page_footer,
    HEADER    => \&page_header,    # in 'template.html'
    LOGOKA    => \&page_logoka,    #   in 'header.html'
    LOGOLINK  => \&page_logolink,  #   in 'header.html'
    LOGOSRC   => \&page_logosrc,   #   in 'header.html'
    MAIN      => \&page_main,      # in 'template.html'
    META      => \&page_meta,      # in 'template.html'
    PREVNEXT  => \&page_prevnext,  # in 'template.html'
    SCRIPT    => \&page_script,    # in 'template.html'
    STYLE     => \&page_style,     # in 'template.html'
    TITLE     => \&page_title,     # in 'template.html'
    TOC       => \&page_toc,
    URL       => \&page_url,       # in 'template.html'
    YEAR      => \&page_year,      # in 'template.html'
    YEARTXT   => \&page_yeartxt,   # in 'template.html'
);

my %author = (
    bkhl    => [ 'Björn Lindström' => 'bkhl@elektrubadur.se'     ],
    markus  => [ 'Markus Persson'  => 'mp@klingonska.org'        ],
    wallius => [ 'Robert Wallius'  => 'wallius@rit.se'           ],
    yens    => [ 'Yens Wahlgren'   => 'yenswahlgren@hotmail.com' ],
    zrajm   => [ 'zrajm'           => 'zrajm@klingonska.org'     ],
);

my $lang = "en";
my %string = (
    toc     => { en => "Contents",      sv => "Innehåll"        },
    prev    => { en => "Previous Page", sv => "Föregående sida" },
    next    => { en => "Next Page",     sv => "Nästa sida"      },
    changed => { en => "Updated",       sv => "Uppdaterad"      },
    month => {
        en => sub {
            my ($year, $month, $day, $hour, $minute) = @_;
            $day =~ s/^0+//;
            my @month = qw(
                January   February  March      April    May       June
                July      August    September  October  November  December
            );
            "$month[$month-1] $day, $year";
        },
        sv => sub {
            my ($year, $month, $day, $hour, $minute) = @_;
            $day =~ s/^0+//;
            my @month = qw(
                januari   februari  mars       april    maj       juni
                juli      augusti   september  oktober  november  december
            );
            "$day $month[$month-1] $year";
        }
    },
);


###############################################################################
##                                                                           ##
##  Initialization                                                           ##
##                                                                           ##
###############################################################################


# load perl modules
# (gracefully suggest which Debian packages are missing on failure)
BEGIN {
    my %module = (
        "Text::MultiMarkdown" => {
            deb => "libtext-multimarkdown-perl",
            #import => [ "markdown" ],
        },
    );
    my @failed = ();
    for my $module (keys %module) {
        (my $file = "$module.pm") =~ s{::}{/}g;
        my $bad = 1;
        for my $dir (@INC) {
            if (-e "$dir/$file") {
                $bad = "";
                eval "require $module;";
                $module->import(@{$module{$module}{import}});
                last;
            }
        }
        push @failed, $module if $bad;
    }
    if (@failed) {
        warn "Cannot find perl module(s): ", join(", ", sort(@failed)), "\n",
            "To install them (on Debian/Ubuntu) run:\n\n",
            "    apt-get install ",
            join(" ", sort map $module{$_}{deb}, @failed),
            "\n\n";
        exit 50;
    }
}

# CAVEAT: short opts cannot be bundled
# (Comments displayed by "--help" begin with "##".)
my %cfg = ( output => -t STDOUT ? "%.html" : "-" );
{
    (my $bin = $0) =~ s{^.*/}{};
    ## Usage: markdown2html [OPTION]... FILE... [DIR]
    ## Generate HTML file(s) from MultiMarkdown source in FILE(s).
    ##
    my ($bad, @unparsed) = (0, ());
    while (@ARGV) {
        local $_ = shift @ARGV;
        m/^--$/ and last;
        m/^(--[^=]+)=(.*)$/ and do { $_ = $1; unshift @ARGV, $2 }; # longopt arg
        m/^(-[^-])(.+)$/    and do { $_ = $1; unshift @ARGV, $2 }; # shortopt arg
        ##   -b, --base=DIR       root path (used for breadcrumb generation etc.)
        m/^(-b|--base)$/ and do { $cfg{rootpath} = shift; next };
        ##   -h, --help           display this help and exit
        m/^(-h|--help)$/ and do { help(); exit 0 };
        ##   -o, --output=FILE    output filename (default: %.html, '-' if piped)
        m/^(-o|--output)$/ and do { $cfg{output} = shift; next };
        ##   -T, --no-template    suppress page template for header/footer
        m/^(-T|--no-template)$/ and do { $cfg{template} = ""; next };
        ##   -t, --template=FILE  output filename (default: %.html, '-' if piped)
        m/^(-t|--template)$/ and do { $cfg{template} = shift; next };
        # ADD OPTS HERE
        /^-/ and do { warn "$bin: unknown option '$_'\n"; $bad++; next };
        push @unparsed, $_;
    }
    exit 1 if $bad;
    @ARGV = @unparsed;
    ##
    ## NOTE: Input cannot be given on STDIN since file date/time is used.
    ##
    ## If FILE for '--output' begins with '%', it is interpreted as a pattern.
    ## Each leading '%' strips off one file extension from the input filename,
    ## and any trailing characters are thereafter added to form the output
    ## filename ('--output=%.html' thus turns 'index.txt' into 'index.html').
    ##
    ## If FILE is '-', then output is sent to standard output (not possible if there are
    ## more than one input file).
    ##
    ## When looking for templates, CSS, etc scans the current dir, then below dirs,
    ## for "includes/template.html" and "includes/page.css".
    die "$bin: not enough arguments\n" .
        "Try `$bin --help' for more information.\n" unless @ARGV;
}
if ($cfg{output} =~ m/^(%*)(.*)$/g) {
    $cfg{add} = $2 eq "-" ? "" : $2;
    $cfg{output} = "";
    if ($1) {                                  # pattern (leading '%')
        my $num = length($1);
        $cfg{strip} = qr/(?:\.[^.]+){0,$num}$/;
    } else {                                   # filename (= no pattern)
        $cfg{strip} = qr/.*/;
        die "$0: with multiple input files '--output' requires a pattern\n"
            if @ARGV > 1;
    }
}



###############################################################################
##                                                                           ##
##  Informational Functions                                                  ##
##                                                                           ##
###############################################################################


sub help {
    my @source = do {
        my $file = realpath($0);               # get name of source file
        open(my $fh, '<', $file) or
            die "$0: Can't open source code for reading of docstrings: $!\n";
        <$fh>;
    };
    foreach (@source) {
        m/^\s+##\s?(.*\n)/ or next;            # only lines beginning with "## "
        print $1;
    }
}



###############################################################################
##                                                                           ##
##  Functions                                                                ##
##                                                                           ##
###############################################################################

{
    package HTML::Template::KA;
    use strict;
    use warnings;
    use Carp;
    use Cwd "realpath";

    sub new {
        my ($class, @arg) = @_;
        my $self = bless({}, $class);
        return $self->set(@arg);
    }

    # return the object
    # allow for () as args
    sub set {
        my ($self) = shift;
        croak "set(): must be called with an even number of arguments" if @_ % 2 != 0;
        my %arg = @_;
        $arg{rootpath} = realpath($arg{rootpath} // ".");
        $self->{$_} = $arg{$_} foreach (keys %arg);
        return $self;
    }

    # Usage: $o->get([setting[,...]]);
    #
    # If called with no args, return the keys of the self object. If called with
    # one (or more) args return the value of all the mentioned keys (in order as
    # named in the args). In scalar context only the first value requested is
    # returned.
    sub get {
        my ($self) = shift;
        return keys %$self unless @_;
        if (wantarray) {
            return map { $self->{$_} } @_;
        } else {
            return $self->{$_[0]};
        }
    }

    # Usage: read_file(FILE);
    #
    # Reads the entire (utf8) FILE and returns its contents as a string.
    sub read_file {
        my ($file) = shift;
        open(my $in, "<:utf8", $file) or croak "cannot open file \"$file\": $!";
        my @line = <$in>              or croak "cannot read file \"$file\": $!";
        return @line;
    }

    # Usage: BOOL = metadata(%META, @TEXT);
    #
    # Extracts any leading metadata fields from @TEXT. Returns FALSE on failure,
    # TRUE otherwise.
    sub metadata(\%\@) {
        my ($hashref, $arrayref) = @_;
        my ($field, $count) = ("", 0, 0);
        foreach (@$arrayref) {
            $count ++;
            if (m/^ (\w*): \s* ([^\n]*)\n /x) {# new metadata field
                if ($1 ne "") {                #   non-comment
                    if (exists $hashref->{$1}) {
                        $hashref->{$1} .= $2;
                    } else {
                        $hashref->{$1}  = $2;
                    }
                }
                $field = $1;
            } elsif (m/^ \s+ ([^\n]*)\n /x) {  # continuation line
                if ($field ne "") {
                    $hashref->{$field} .= " " . $1;
                } else {
                    warn "$0: continuation line may not occur first in "
                        . "metadata or after metadata comment (in line "
                        . "$count)\n";
                    return '';
                }
            } elsif (m/^ \s* $/x) {            # blank line
                if ($count == 1) {
                    warn "$0: 1st line in file may not be blank " .
                        "(in line $count)\n";
                    return '';
                }
                last;
            } else  {                          # all other cases
                warn "$0: metadata is not terminated by blank line " .
                    "(in line $count)\n";
                return '';
            }
        }
        splice(@$arrayref, 0, $count);

        # if title unset in header, use 1st '==' header
        if (not exists($hashref->{title})) {
            (local $_, my $i) = ("", 0);
            $i ++ while $arrayref->[$i] =~ /^$/;
            if (($arrayref->[$i+1] // "") =~ /^=+$/) {
                $_ = ${$arrayref}[$i];
                s#\s* \[\[.*?\]\]##gx;
                chomp();
            }
            $hashref->{title} = $_;
        }
        return 1;
    }

    # Usage: extract_tag($STRING, $HASHREF);
    #
    # Removes all occuring HTML elements <$STRING>...</$STRING> from
    # $HASHREF{"text"} and appends to list $HASHREF{$STRING . "_tags"}. Leading
    # and trailing <$STRING> / </$STRING> are kept exactly as-is. This in
    # intended for use with the <script> and <style> HTML tags.
    #
    # Nothing is returned.
    sub extract_tag($\%) {
        my ($tag_name, $hashref) = @_;
        my $list = $hashref->{ $tag_name . "_tags" } //= [];
        $hashref->{text} =~ s{\s*(<$tag_name\b[^>]*>.*?</$tag_name>)}{
            push(@$list, $1);
            "";
        }ges;
    }

    # Usage: %meta = get_metadata(TEXT);
    #
    # Returns the metadata portion of TEXT.
    sub get_metadata {
        my ($self, $text) = @_;
        # strip off non-metadata (all after first blank line)
        $text =~ s/(?<=\n)\n+(.*)//s;
        carp "read_metadata(): only metadata found in this file -- isn't that odd?" unless $1;
        my %meta = ();
        my ($tag, $line) = (undef, 0);
        for (split(/(?<=\n)/, $text)) {
            $line ++;
            m/^ \s+ (.*) $/xs and do {
                croak "read_metadata(): continuation line with no preceding metadata field in line $line"
                    unless defined($tag);
                $meta{$tag} .= "\n" . $1;
                next;
            };
            m/^ ([^:]*) : \s* (.*) $/x and do {
                $meta{$tag = $1} .= $2;
                next;
            };
            croak "get_metadata(): failed to parse metadata in line $line";
        }
        return %meta;
    }

    # Usage: $OUTPUT = process_xml(\&CODEREF, [$INPUT]);
    #
    # INPUT is assumed to in HTML or XML format. Each string of plain text in
    # INPUT is passed along CODEREF and replaced by the return value therefrom.
    # Plain text is all text not found inside any <...> + the values of any
    # attribute inside such tags.
    #
    # The contents of <style>...</style> and <script>...</script> tags is also
    # left unprocessed.
    #
    # If $INPUT is not provided, $_ is used.
    sub process_xml {
        die "1st argument must be code reference" unless ref($_[0]) eq "CODE";
        my ($coderef, $input) = (@_, $_);
        $input =~ s{ ([^<]*) (<(style|script)\b[^>]*>.*?</\3>|<!--(.*?)-->|<[^>]*?>)? }{
            my ($text, $tag, $comment) = ($1, $2 || "", $4);
            &$coderef($text) .
            do {
                if (defined($comment)) {
                    # HTML comments containing HTML code
                    # (call process_xml() recursivelly)
                    "<!--" . process_xml($coderef, $comment) . "-->";
                } else {
                    # process attribute values of HTML/XML tag
                    # (but ignore the rest if it)
                    $tag =~ s# (?<==") ([^"]*) (?=") # &$coderef($1); #gex;
                    # replace with processed text + tag
                    $tag;
                }
            };
        }gsex;
        return $input;
    }

    # Usage: $OUTPUT = process_xml(\&CODEREF, [$INPUT]);
    #
    # INPUT is assumed to in HTML or XML format. Each string of plain text in
    # INPUT is passed along CODEREF and replaced by the return value therefrom.
    # Plain text is all text not found inside any <...> + the values of any
    # attribute inside such tags.
    #
    # The contents of <style>...</style> and <script>...</script> tags is also
    # left unprocessed.
    #
    # If $INPUT is not provided, $_ is used.
    sub process_xml_except_args {
        die "1st argument must be code reference" unless ref($_[0]) eq "CODE";
        my ($coderef, $input) = (@_, $_);
        $input =~ s{ ([^<]*) (<(style|script)\b[^>]*>.*?</\3>|<[^>]*?>)? }{
            my ($text, $tag) = ($1, $2 || "", $4);
            &$coderef($text) . $tag;
        }gsex;
        return $input;
    }

    sub process_paragraph {
        my ($text) = @_;
        # <<...>> marks translations, {...} marks klingon
        $text =~ s#<<(.*?)>>#<i class=translation>$1</i>#gs;
        $text =~ s#\{(.*?)\}#<b lang=tlh>$1</b>#gs;
        $text =~ s{<b\b([^>]*)\blang=(['"]?)tlh\b\2([^>]*)>(.*?)</b>}{
            my ($preattr, $postattr, $content) = ($1, $3, $4);
            "<b" . $preattr . "lang=tlh" . $postattr
                . (is_affix($content) ? " class=nobr" : "") . ">"
                . prettify_tlh($content) . "</b>";
        }gesx;
        return process_xml_except_args(sub {
            local $_ = shift;
            s{(K-E|E-K)}{<span class=nobr>$1</span>}g;
            return $_;
        }, $text);
    }

    # If paragraph starts with one of these, don't add <p> tag.
    my $p_level_tags = "address|article|aside|blockquote|div|dl|fieldset|"
        . "footer|form|h1|h2|h3|h4|h5|h6|header|hr|menu|nav|ol|pre|section|"
        . "table|ul|"
        . "li|dl|dt|figure";
    sub markdown {
        my ($self, $hashref) = @_;
        local $_ = $hashref->{text};

        s{ \n* \[\[eof\]\] \n* $ }{}ix;  # strip eof marker
        s#<>#&nbsp;#g;                   # <> = &nbsp;

        # parse with multimarkdown
        my $obj = new Text::MultiMarkdown(
            empty_element_suffix => '>',
            strip_metadata       => '',
            tab_width            => 4,
            use_metadata         => '',
        );

        # Process each paragraph.
        s/^\n+//;
        $_ = join "\n\n", map {
            # If starting with <p> level tag, remember to strip it aftewards.
            my $strip_p_tag = m#^\s*</?($p_level_tags)\b# ? 1 : 0;

            # FIXME: markdown() chokes on HTML tags that contain space &
            # newlines between the attributes, so should we clean up all that
            # (except in attribute values), and *then* run everything through
            # markdown()?
            $_ = process_paragraph($_);
            if (not $strip_p_tag) {
                $_ = $obj->markdown($_);
            }
            chomp;
            $_;
        } split /\n{2,}/, $_;
        $_ = $self->process_template($_, %$hashref);

        # [[...]] comments
        s{ <p> \[\[ (.*?) \]\] </p> }{<div class=comment><p>$1</p></div>}gxs;
        s{ \[\[ (.*?) \]\] }{<span class=comment>$1</span>}gxs;

        # clean up some (useless) empty HTML elements
        s{ \s* <thead> \s* </thead> }{}gix;
        s{ \s* <col \s* /> }{}gix;

        # remove whitspace in empty <td> cells
        s{(<td\b[^>]*>) \s+ (</td>)}{$1$2}gix;

        # clean up headline "id" attribute
        s{ <(h[1-7]) \s+ ([^>]*)> (.*?) </\1> }{
            my ($h, $attr, $cont) = ($1, $2, $3);
            my $name = ($cont =~ s/^\s*\[(.*?)\]\s*//) ? $1 : $cont;
            $name =~ s{ \s* < (\w+) [^>]*> .*? </\1> \s* }{}gix; # strip <x>...</x>
            $name =~ s{ \s* \[ .*? \] \s* }{}gix;                # strip [...]
            if ($name =~ /^ ((?:\d+\.)* \d+) /x) {
                $name = $1;
            }
            $name =~ s/ ^ (?=\d) /_/x;      # precede leading digit with underscore
            $name =~ s/ [^\d\w]+ /_/xg;     # replace non-alphanumeric with underscore
            $attr =~ s{ id="[^"]*" }{id="$name"}xi;
            "<$h $attr>$cont</$h>"
        }gixme;
        return $_;
    }

    sub split_tlh_syllables {
        my ($str) = @_;
        return split /(?=(?:[bDHjlmnpqQrStvwy'’]|ch|gh|ng|tlh)[aeIou])/, $str;
    }

    # Typographical quotes + insert hyphens.
    sub prettify_tlh {
        my ($str) = @_;
        # FIXME: HTML tags should be ignored when hyphenating
        # (for example see site/ref/loc.txt which uses <u>...</u>)
        for ($str) {
            s/'/’/g;
            s{(?<![a-zA-Z0-9'’])([a-zA-Z0-9'’]+)(?![a-zA-Z0-9'’])}{
                join("­", split_tlh_syllables($1));
            }ge;
        }
        return $str;
    }

    sub is_affix {
        my ($str) = @_;
        return 1 if $str =~ /^(?: -[a-zA-Z'’]+ | [a-zA-Z'’]+- )$/x;
        return 0;
    }

    # Usage: $obj->process_file(sourcefile => FILE, sourcedate => EPOCH[, template => HTMLFILE]);
    #
    # Process named $FILE, applying the $TEMPLATE_FILE and return processed
    # result as a string.
    sub process_file {
        my ($self, %meta) = @_;
        my @text = read_file($meta{sourcefile});
        metadata(%meta, @text) or exit 5;
        $meta{text} = join("", @text);
        extract_tag('style', %meta);
        extract_tag('script', %meta);

        # FIXME: should ignore ISO dates inside <time>...</time> tags
        $meta{text} = $self->markdown(\%meta);

        my $page = "";
        if (defined($meta{template})) {
            $page = join("", read_file($meta{template}));
            $page = $self->process_template($page, %meta);
        } else {
            $page = $self->process_template($meta{text}, %meta);
        }

        sub replace {
            local $_ = shift;
            # quote replacement
            # FIXME: should distinguish between 'lang=en' and 'lang=sv'
            my %repl = (
                # typographical quotes
                # #s#"\b#“#g;  # english only
                '"'   => '”',
                # #s#"\b#‘#g;  # english only (not in Klingon!)
                "'"   => '’',
            );
            s/['"]/$repl{$&}/g;

            s{(?<!-)(---?)(?!-)}{                         # typographical en- and em-dashes
                $1 eq '--' ? '&ndash;' : '&mdash;';
            }ge;
            return $_;
        };
        return process_xml(\&replace, $page);
    }

    sub process_template {
        my ($self, $text, %meta) = @_;
        $text =~ s{ (\h*) <!--([A-Z]+)--> (\n?) }{
            my ($indent, $include, $newline) = ($1, $2, $3);
            if (exists($code{$include})) {
                my @out = &{ $code{$include} }($self, %meta);
                join("\n", map { "$indent$_" } @out) . (@out ? $newline : "");
            } else {
                $&;
            }
        }gexs;
        return $text;
    }
}

sub FALSE { "" }
sub TRUE  { 1  }

# Usage: @HTML = get_crumbs($FILE);
# Usage: @HTML = get_crumbs($FILE, $BASEURL);
# Usage: @HTML = get_crumbs($FILE, $BASEURL, $ROOTPATH);
#
# Return list of '<a href="URL">LINKTEXT</a>' links, with the first pointing to
# the index page in current directory, the last pointing $FILE, and those in
# between links to all the intermediate pages in the directory structure.
#
# If $FILE ends in slash "index.html" is appended.
#
# URL is prefixed with $BASEURL (if specified). Any trailing "index.html" is
# also removed from URL.
#
# If ROOTPATH is given, then files are only searched down to this directory,
# i.e. if you specify FILE = x/y/z/gaga.txt, and ROOTPATH = x/y then crumbs are
# generated for "x/y/ > x/y/z/ > x/y/z/gaga.txt", while if no ROOTPATH was
# given then the full range "./ > x/ > x/y/ > x/y/z/ > x/y/z/gaga.txt" would be
# generated.
#
# LINKTEXT is read from each file in turn. It is extracted from this file's
# <title> element (everything up to the first &ndash; is included in LINKTEXT).
#
# Example output:
#     <a href="http://klingonska.org/">Home</a>
#     <a href="http://klingonska.org/songs/">Songs in Klingon</a>
#     <a href="http://klingonska.org/songs/tahjaj_wo/">taHjaj wo&rsquo;</a>
#
# NOTE: "&rsquo;" above was read literally from "songs/tahjaj_wo/index.html" --
# thus function does not do any HTML conversion or escaping of any kind.
#
sub get_crumbs {
    my ($pagefile, $base_url, $rootpath) = @_;
    $pagefile =~ s#^\Q$rootpath\E(?:/|$)##;
    $pagefile =~ s#/index\.(html|txt)$##;

    my @crumb = get_crumb_filenames($pagefile, $rootpath);
    my $i = 0;
    return map {
        # FIXME should error if page_title() return undef
        my $file  = "$rootpath/$_";
        my $title = ($_ =~ /^index.(txt|html)$/) ? "Home" : file_title($file);
        s#(?:^|(?<=/))index\.\w+$##;  # strip 'index.*'
        s#\.txt$#\.html#;             # replace file ext '.txt' -> '.html'
        '<a href="' . ($base_url || "") . $_ . '"'
            . (($i++ == $#crumb) ? ' itemprop=url' : '')
            . '>' . $title . '</a>';
    } @crumb;
}


# Usage: @FILE = get_crumb_filenames($FILE, $ROOTPATH);
#
# Returns source @FILE name(s) of all pages that should linked to in the bread
# crumb of $FILE. Only existing files included, so should there be a directory
# without any apropriate index file, it will be removed from the returned
# @FILE(s).
#
# Given $FILE 'ref/adv.txt' (walking from $ROOTPATH/$FILE, to $ROOTPATH, and
# returning filenames relative to $ROOTPATH) the following will be returned:
#
#     "index.txt"     # the main page
#     "ref/index.txt" # if that file exists
#     "ref/adv.txt"   # the $FILE given
#
# Notice that, since these are paths including filenames, you'll see
# `canon/index.txt` (or, more rarely, `canon/index.html` -- if the *source*
# file is an HTML file), even though the bread crumb links should always point
# to the directory, rather than include the name of the index file of the
# directory.
#
sub get_crumb_filenames {
    my ($file, $rootpath) = @_;
    # path components for $file
    my @file = ($file =~ /^(index\.[a-z]+)?$/) ? () : split(m#/#, $file);

    # previous dir names + current file
    my @crumb = ("", map { join("/", @file[0..$_]) } 0..$#file);

    # append 'index.html' or 'index.txt' where needed
    # return only existing files
    return map {
        if (-f "$rootpath/$_") {
            $_;
        } elsif (-f "$rootpath/$_/index.txt") {
            $_ eq "" ? "index.txt"  : "$_/index.txt";
        } elsif (-f "$rootpath/$_/index.html") {
            $_ eq "" ? "index.html" : "$_/index.html";
        } elsif (-f "$rootpath/$_/index.cgi") {
            $_ eq "" ? "index.cgi" : "$_/index.cgi";
        } else {
            ();
        }
    } @crumb;
}

sub script_tag {
    my ($script, $targetfile) = @_;
    return '<script src="' . rel_filename(
        find_include_file($script, $targetfile),
        $targetfile,
    ) . '"></script>';
}

# Usage: $TITLE = file_title($HTMLFILE);
#
# Returns $TITLE of $HTMLFILE. If $HTMLFILE ends in slash (/) "index.html" is
# appended to the filename before an attempt is made to read it.
#
# $TITLE is stripped of any leading or trailing "Klingonska Akademien" string.
#
sub file_title {
    my ($file) = @_;
    local $_ = read_file($file);
    if (not defined($_)) {                # file didn't exist
        $file =~ m#([^/]+)(/|/index.html)?$#;
        return ucfirst($1);               # use part of path
    }

    if ($file =~ m/\.html$/) {            # HTML file
        if (my ($title) = m#<title>(.*?)</title>#i) {
            for ($title) {
                s/\.$//;
                s/ \s* &ndash;.*//x
                    or s/^ \s* Klingonska \s+ Akademien \s+ (&ndash;|-) \s* //x
                    or s/  \s* - \s+ Klingonska \s+ Akademien \s* $//x
                    or s/ \s* \( \s* Klingonska \s+ Akademien \s* \) \s* //x;
            }
            return $title;
        }
    }

    # If file is an index file (index.txt) it should use only the 'title'
    # metadata field, not any title given in the text body (text body title
    # will only be used if 'title' metadata is missing).
    if ($file =~ m/\.txt$/) {
        my ($head, $body) = split(/\n\n+/, $_, 2);
        my $page_title = do {
            my ($x) = $body =~ m/^([^\n]+)$/mx;      # 1st line in body
            $file =~ m#(?:^|/)index\.txt$#           # but in 'index.txt'
                and $head =~ m/^title: \s* (.*) $/mx #   use 'title' field
                and $x = $1;                         #   if there is one
            $x;
        };
        $page_title =~ s/ \s * \[\[.*?\]\] //gx;
        # return "$page_title -- $project_title"
        #     if defined($project_title);
        return $page_title;
    }
    return undef;
}

# Usage: $abs_filename = find_include_file(REL_INCLUDE_FILE, SOURCE_FILE);
#
# Returns the absolute filename of the file which should be included in
# SOURCE_FILE. Name of REL_INCLUDE_FILE should be given relative to
# SOURCE_FILE's position in the file hiearchy.
#
# Dies if REL_INCLUDE_FILE could not be found.
#
sub find_include_file {
    my ($relfile, $basefile) = @_;
    $basefile = dirname(realpath($basefile));
    use File::Spec;
    my ($vol, $dirs) = File::Spec->splitpath($basefile);
    my @dir = File::Spec->splitdir($dirs);
    my $glob = ($relfile =~ /\*/) ? TRUE : FALSE;
    while (@dir) {
        my $absfile = File::Spec->catpath(
            $vol, File::Spec->catdir(@dir), $relfile
        );
        if ($glob) {
            my @file = glob($absfile);
            return $file[0] if @file;
        } else {
            return $absfile if -e $absfile;
        }
        pop @dir;
    }
    die "Failed to find include file '$relfile' for '$basefile'";
}

sub page_meta {
    my ($self, %meta) = @_;
    return () unless $meta{desc};
    return '<meta name=description content="' . $meta{desc} . '">';
}

# return page url
sub page_url {
    my ($self, %meta) = @_;
    my ($file, $root) = ($meta{sourcefile}, $meta{sourcebase});
    for ($file) {
        s#^\Q$root\E(?:/|$)##;
        s#\.[^/.]{1,4}$#.html#; # replace any extension with '.html'
        s#index\.html$##;       # remove trailing 'index.html'
    }
    return "http://klingonska.org/$file";
}

sub page_crumbs {
    my ($self, %meta) = @_;
    my @crumb = get_crumbs(
        $meta{sourcefile},
        "http://klingonska.org/",
        $meta{sourcebase},
    );
    $_ .= " &#8250;" foreach @crumb[0..$#crumb-1];
    return @crumb;
}

# return time in "2009-12-31, 24:59" format
sub page_changed {
    my ($self, %meta) = @_;
    #<time pubdate itemprop=dateModified datetime="2012-05-13 02:56+0200">May 13, 2012</time>
    use Date::Format;
    use Date::Parse;
    die "Missing 'updated' metadata field in file '$meta{sourcefile}'\n"
        unless $meta{updated};
    my $epoch = str2time($meta{updated})
        or die "Failed to parse 'updated' field in file '$meta{sourcefile}'\n";
    my $time = time2str("%Y-%m-%d %H:%M%z", $epoch);
    return $string{changed}{$lang}
        . ' <time pubdate itemprop=dateModified datetime="' . $time . '">'
        . &{ $string{month}{$lang} }(split /[-: ]|(?=[-+]\d{4}$)/, $time)
        . '</time>';
}

sub page_logoka {
    my ($self, %meta) = @_;
    my $file = find_include_file("pic/ka.gif", $meta{sourcefile});
    $file    = rel_filename($file, $meta{sourcefile});

    # FIXME "width" and "height" should be read from the image itself
    my $img  = '<img src="' . $file . '" width=600 height=176 ' .
        'alt="Klingonska Akademien">';

    # output file is root index.html
    if ($meta{sourcefile} =~ m#^\Q$meta{sourcebase}\E/index\.(html|txt)$#) {
        return $img;
    }
    return '<a href="' . page_logolink($self, %meta) . "\">$img</a>";
}

# if index.html point to previous dir
# otherwise point to this dir
sub page_logolink {
    my ($self, %meta) = @_;
    return $meta{up} if exists $meta{up};
    return ".." if $meta{sourcefile} =~ m#(?:^|(?<=/))index.[^/.]*$#;
    return ".";
}

sub page_logosrc {
    my ($self, %meta) = @_;
    return rel_filename(
        find_include_file("pic/ka-logo.svg", $meta{targetfile}),
        $meta{targetfile},
    );
}

sub page_year {
    my ($self, %meta) = @_;
    return "MISSING YEAR" unless exists($meta{year});
    my $year = $meta{year};
    for ($year) {
        {
            my $first = ' itemprop=copyrightYear';
            s{ (\b\d{4}\b) }{
                my $x = "<time$first>$1</time>";
                $first = "";
                $x;
            }gex;
        }
        s#(?<!-)-{1,2}(?!-)#&ndash;#g;
    }
    return $year;
}

sub page_yeartxt {
    my ($self, %meta) = @_;
    return "MISSING YEAR" unless exists($meta{year});
    (my $year = $meta{year}) =~ s#(?<!-)-{1,2}(?!-)#–#g;
    return $year;
}

sub page_author {
    my ($self, %meta) = @_;
    return "MISSING AUTHOR" unless exists($meta{author});
    my @author = map {
        exists($author{$_})
            ? '<a href="mailto:' . $author{$_}[1]
                . '" rel=author itemprop=author>'
                . $author{$_}[0] . '</a>'
            : $_;
    } split(/,\s*/, $meta{author});
    $_ .= " &amp;" foreach @author[0..$#author-1];
    return @author;
}

sub page_authortxt {
    my ($self, %meta) = @_;
    return "MISSING AUTHOR" unless exists($meta{author});
    my @author = split(/,\s*/, $meta{author});
    # Join author names (last two with '&', all others with ',').
    return $#author
        ? join(", ", @author[0..$#author-2], join(" & ", @author[-2,-1]))
        : $author[0];
}

sub page_style {
    my ($self, %meta) = @_;
    my @style_tag  = $meta{style_tags} ? @{ $meta{style_tags} } : ();
    my @style_file = map {
        "includes/$_"
    } 'base.css', ($meta{style}        # always include base stylesheet
        ? split(/\s+/, $meta{style})   # user override defaults
        : ()
    );
    return (map {
        '<link rel=stylesheet href="' .
        rel_filename(
            find_include_file($_, $meta{targetfile}),
            $meta{targetfile},
        ) . '">';
    } @style_file), @style_tag;
}

# Page title should be:
# 1st Page Headline - Metadata Title - Klingonska Akademien
#
# "Klingonska Akademien" is a string literal, which is always present, the
# other two components may or may not be present.
sub page_title {
    my ($self, %meta) = @_;
    my @title = ();
    push(@title, $meta{title}) if exists $meta{title};
    if ($meta{sourcefile} !~ m#(?:^|/)index.txt$#) {
        if ($meta{text} =~ m#^\s*<h1\b[^<>]*>(.*)</h1>#i) {
            local $_ = $1;
            s#\s*<span\b[^<>]*>.*?</span>##gx;
            s/\.$//;
            unshift(@title, $_) unless $_ eq $title[0];
        }
    }
    s#<[^>]*>##g foreach @title; # strip all HTML inside title
    return "Klingonska Akademien" if @title == 1 and $title[0] eq "";
    return join(" -- ", @title) . " -- Klingonska Akademien";
}


sub rel_filename {
    my ($file, $base) = @_;
    $base = dirname(realpath($base));
    use File::Spec;
    $file = File::Spec->abs2rel($file, $base)
        if File::Spec->file_name_is_absolute($file);
    return $file;
}


sub dirname {
    my ($file) = @_;
    use File::Spec;
    return File::Spec->catpath((File::Spec->splitpath($file))[0,1]);
}


sub page_toc {
    # FIXME: should combine title metadata field with first header in text
    my ($self, %meta) = @_;
    my $li_open = FALSE;
    (my $dir = $meta{sourcefile}) =~ s#/*[^/]*$##;

    my $depth = 0;
    my $prev_depth = 0;

    my $toc .= qq{<div class=toc>\n};
    for my $file (glob("$dir/*.txt")) {
        next if realpath($file) eq realpath($meta{sourcefile});

        my $count   = 0;
        my $text    = read_file($file);
        my $outfile = $file;
        for ($outfile) {
            s#^$dir/(.*?)##;
            s#\.[^.]+$#.html#;
        }

        while ($text =~ m/\n ([^\n]+)\n+ ([=-])\2+\n /gx) {
            # get full heading + underline type ("=" or "-")
            my ($heading, $underline) = ($1, $2);

            # get section id (part after # in HTML-link)
            my $section = "";
            if ($heading =~ m/^([0-9.]*?)\.?\s/x) {     # heading with number
                $section = $1;
                # subsection depth based on section number
                $depth = my @x = split(/\./, $section); #   subsection depth
            } else {                                    # heading without number
                $section = $heading;
                $section =~ s/ \s * \[\[.*?\]\] $//x;
                $depth = 1;
            }
            $depth ++ if $depth == 1 and $underline eq "-";
            $section =~ s/\.$//;

            # put any [[...]] after heading's link
            my $comment = ($heading =~ s#( \s* \[\[ .*? \]\] $ )##x ? $1 : "");

            # output <ul> / </ul> when depth changes
            if ($depth > $prev_depth) {
                $toc .= "\n" . ("    " x $prev_depth) . "<ul>\n";
                $li_open = FALSE;
            } elsif ($depth < $prev_depth) {
                for (reverse $depth .. $prev_depth-1) {
                    $toc .= "\n" . ("    " x $_) . "</ul>";
                }
            }
            $prev_depth = $depth;

            # output entry
            if ($li_open) {
                $toc .= "\n";
                $li_open = FALSE;
            }

            for ($section) {
                s/ ^ (?=\d) /_/x;      # precede leading digit with underscore
                s/ [^\d\w]+ /_/xg;     # replace non-alphanumeric with underscore
            }
            $toc .= ("    " x $depth) . qq{<li><a href="$outfile} .
                ($count ? "#$section" : "") .
                qq{">$heading</a>$comment};
            $count ++;
            $li_open = TRUE;
        }
    }
    # output trailing </ul>s
    for (reverse 0 .. $depth-1) {
        $toc .= "\n" . ("    " x $_) . "</ul>\n";
    }
    $toc .= "</div>\n";
    return $toc;
}

sub page_header {
    # FIXME: should find headerfile relative to the processed file's name
    my ($self, %meta) = @_;
    my $text = read_file(
        find_include_file("includes/header.html", $meta{sourcefile})
    );
    my @text = split(/\n/, $self->process_template($text, %meta));

    # output file is root index.html
    if ($meta{sourcefile} =~ m#^\Q$meta{sourcebase}\E/index\.(html|txt)$#) {
        return @text;
    }
    return '<a href="' . page_logolink($self, %meta) . '/">',
        (map { "  $_" } @text),
        '</a>';
}

sub urlify {
    local ($_) = @_;
    return $_ if m#/$#;
    return "$_/" if m#\.$#;
    return "$_.html";
}

# Metadata fields 'prev', 'next' and 'toc' (for 'table-of-contents')
sub page_prevnext {
    my ($self, %meta) = @_;
    my @link = map {
        exists($meta{$_})
            ? '<a href="' . urlify($meta{$_}) . '">' . $string{$_}{$lang} . '</a>'
            : ();
    } qw/prev toc next/;
    return @link
        ? ('<p class=prevnext>', map("    $_", @link), '</p>')
        : ();
}

sub page_script {
    my ($self, %meta) = @_;
    my @script_tag  = $meta{script_tags} ? @{ $meta{script_tags} }     : ();
    my @script_file = $meta{script}      ? split(/\s+/, $meta{script}) : ();
    return (map {
        script_tag("includes/$_", $meta{targetfile});
    } 'titlewrap.js', @script_file), @script_tag;
}

sub page_footer {
    # FIXME: should find headerfile relative to the processed file's name
    my ($self, %meta) = @_;
    my $text = read_file(find_include_file("includes/footer.html", $meta{sourcefile}));
    return $self->process_template($text, %meta);
}

sub page_main {
    my ($self, %meta) = @_;
    return $meta{text};
}

sub read_file {
    my ($file) = @_;
    open my $in, "<", $file or die "Failed to open file '$file' for reading: $!\n";
    my @line;
    while (not eof $in) {
        defined(my $tmp = <$in>) or die "Failed to read file '$file': $!\n";
        push @line, $tmp;
    }
    return wantarray ? @line : join("", @line);
}

sub write_file {
    my ($file, $data) = @_;
    if (defined($file) and $file !~ /^-?$/) {
        open my $out, ">", $file or die "Failed to open file '$file' for writing: $!\n";
        print $out $data         or die "Failed to write to file '$file': $!\n";
        close($out)              or die "Failed to close file '$file' after writing: $!\n";
    } else {
        print $data              or die "Failed to write to standard output: $!\n";
    }
    return 1;
}


###############################################################################
##                                                                           ##
##  Main Program                                                             ##
##                                                                           ##
###############################################################################

# init "language"
my $obj = new HTML::Template::KA(rules => \%code);

foreach my $file (@ARGV) {
    (my $outfile = $file) =~ s/$cfg{strip}/$cfg{add}/;
    print "HTMLifying '$file' -> '$outfile'\n" if $outfile;

    my $data = $obj->process_file(
        targetfile => realpath($outfile),
        sourcebase => realpath($cfg{rootpath}),
        sourcedate => (stat($file))[9],
        sourcefile => realpath($file),
        ($cfg{template}
             ? (template => find_include_file($cfg{template}, $file))
             : ()
         ),
    );
    write_file($outfile, $data);
}

#[eof]
